<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .father {
      width: 400px;
      height: 400px;
      background-color: #0094ff;
    }
    .son {
      width: 200px;
      height: 200px;
      background-color: red;
      margin: 50px;
    }
    .content {
      width: 400px;
      height: 100px;
      background-color: yellow;
      opacity: 0;
      transition: opacity .3s;
    }
  </style>
</head>
<body>
  <div class="father">
    父盒子
    <div class="content">我是隐藏起来的内容</div>
    <div class="son">子盒子</div>
  </div>
  <script>
    // 需求1: 鼠标经过父盒子, 显示 .content
    // 需求2: 鼠标离开父盒子, 隐藏 .content
    // 获取元素
    const father = document.querySelector('.father')
    const son = document.querySelector('.son')
    const content = document.querySelector('.content')
    
    // mouseover / mouseout  鼠标经过 鼠标离开
    father.addEventListener('mouseenter', function() {
      // alert('经过爸爸了')
      console.log('经过爸爸了')
      // 经过子盒子, 冒泡给父盒子, 没有必要再次触发事件
      content.style.opacity = 1
    })
    // mouseout 的判定问题: 从父盒子移入到子盒子会被判定为离开了父盒子!
    // father.addEventListener('mouseout', function() {
    // mouseenter 和 mouseleave 不会冒泡, 也解决了 mouseout 的判定问题
    // mouseover 和 mouseout 会冒泡
    father.addEventListener('mouseleave', function() {
      // alert('经过爸爸了')
      console.log('离开爸爸了')
      // 经过子盒子, 冒泡给父盒子, 没有必要再次触发事件
      content.style.opacity = 0
    })
    
    son.addEventListener('mouseenter', function(e) {
      console.log('经过儿子了')
      // alert('经过儿子了')
      // e.stopPropagation()
    })
    son.addEventListener('mouseleave', function(e) {
      console.log('离开儿子了')
      // alert('经过儿子了')
      // e.stopPropagation()
    })
  </script>
</body>
</html>